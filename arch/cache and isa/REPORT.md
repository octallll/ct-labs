| Лабораторная работа №4    | M3139 | Архитектура ЭВМ |
| ------------------------- | ----------- | ---- |
| Кэш и кодирование команд  | Свешников Борис Юрьевич       | 2024 |

# Расчёт параметров системы

Полученные параметры системы

| Параметр         | Значение (с единицами измерения) |
| ---------------- | --- |
| MEM_SIZE         | 262144 байт |
| ADDR_LEN         | 18 бит |
| CACHE_WAY        | 4 |
| CACHE_TAG_LEN    | 9 бит |
| CACHE_INDEX_LEN  | 3 бит |
| CACHE_OFFSET_LEN | 6 бит |
| CACHE_SIZE       | 2048 байт |
| CACHE_LINE_SIZE  | 64 байт |
| CACHE_LINE_COUNT | 32 |
| CACHE_SETS       | 8 |

Расчёт:

У меня первый вариант и по условию мне даны

| Параметр         | Значение (с единицами измерения) |
| ---------------- | --- |
| ADDR_LEN         | 18 бит |
| CACHE_INDEX_LEN  | 3 бит |
| CACHE_LINE_SIZE  | 64 байт |
| CACHE_LINE_COUNT | 32 |

Общий размер памяти это 2 в степени длина адреса

${MEM\\_SIZE} = 2^{ADDR\\_LEN}$

Общий размер кэша это количество кэш линий в кэше, умноженное на размер кэш линии

$CACHE\\_SIZE = CACHE\\_LINE\\_SIZE * CACHE\\_LINE\\_COUNT$

Размер смещения равен двоичному логарифму от размера кэш линии

$CACHE\\_OFFSET\\_SIZE = log_2{CACHE\\_LINE\\_SIZE}$

Длина тега это длина индекса сложенная с длиной смещения и вычтенная из общей длины адреса

$CACHE\\_TAG\\_LEN = ADDR\\_LEN - CACHE\\_INDEX\\_LEN - CACHE\\_OFFSET\\_LEN$

Размер блоков в кэше это 2 в степени длина индекса блока в кэше

$CACHE\\_SETS = 2^{CACHE\\_INDEX\\_LEN}$

Количество кэш линий в блоке это количество линий в кэше поделить на количество блоков

$CACHE\\_WAY = CACHE\\_LINE\\_COUNT / CACHE\\_SETS$

# Структура кэш-линии

##  Файловая структура

Проект включает в себя 3 файла:
1. `main.cpp` - основной файл переводящий код из Ассемблер в машинный
2. `CommandInformation.h` - файл включающий всю вспомогательню информации для кодирования команд
3. `LRUandPLRU.h` - файл со структурой кэшей с политикой вытеснения LRU и bit-pLRU

## Кэш

В файле `LRUandPLRU.h` я храню класс `CacheLine`, в котором поддерживаю tag линии, время ее последнего испольвания (Для политики `LRU`) и бит использования (Для политик `bit-pLRU`)

Далее в файле расположены классы `LRU` и `pLRU`, каждый из которых кэш с соответствующей политикой вытеснения.

## LRU

В классе `LRU` я храню двумерный массив из `CacheLine`, размера соответственного равного $CACHE\\_SETS$ на $CACHE\\_WAY$ и счетчки попаданий в кэш. Также в классе поддерживается временной таймер `timer`. В классе есть две функции: `memoryGet` и `insertData`.

Функция `memoryGet` принимает адрес в памяти и с помощью функций `getTag` и `getIndex` получает соответственно `tag` и `index` линии в кэше. Функция проверяет есть ли в блоке кэша с номером `index` линия с тэгом `tag`. Если линия есть, то ее таймер обновляется текущим таймером кэша.

Функция `insertData` принимает адрес и также получает `tag` и `index` для линии. Далее в блоке находится линия с минимальным таймером и заменяется на ту, которую мы вставляем.


## bit-pLRU

Структура класса аналогична `LRU`, за исключением того, что `timer` нам больше не нужен.

Функция `memoryGet` аналогично проверяет наличие линии в кэше по `tag` и `index`. Если линия найдена то `useBit` устанавливается в 1.

Функция `insertData` ищет первую линию `useBit` которой установлен в 0 и заменяет ее на линию, которую мы хотим вставить. Если после вставки все `useBit` в блоке кэша установлены в 1, то они сбрасываются в 0.

# Кодирование команд

Для кодирования команд у меня есть файлик `CommandInformation.h`, в нем лежат различные opcode, funct3 codes, funct7 codes для кодирования. А также словари для перевода регистров из `asm` формата в `bin`. Для упрощения кодирования я для каждой команды определяю ее тип по документации. Для большинства типов кодирование однотипно (кроме типа `I`, там команды разбиваются на еще несколько групп). Также для кодирования я использую функции `getIntegerValue`, которая переводит константу записанную в виде строки в десятичный вид и функции `getFromIntInBin` и `getBitFromIntInBin`, которые возвращают бинарную строку из диапозона бит данного числа, либо один бит заданного числа.

# Считывание и обработка команд

Команды я считываю с помощью функции `readCommands`, которая считывает строку из файла и преобразует ее в `vector` из `string`, состоящий из названия команды и ее аргументов. Корректность введенной команды определяется так: сперва считывается `commandName` и проверяется, что это корректное имя команды. Далее я обрабатываю аргументы, которые разделяются запятыми. Для помощи в проверке аргументов у меня есть функция `getExpectedArguments`, которая для каждой команды возвращает `vector` состоящий из `ArgumentType`: `Register`, `Const` или `FenceArgument` (`Fence` к моему большому сожалению может принимать как константу, так и строку в виде аргумента).

Для обработки команд, я храню два кэша: `LRU` и `pLRU`, массив `memory`, который изображает нашу память и `PC` - programm counter. Еще у меня есть функция `pickCache`, которая делает обращения к кэшам, и если там не нашлось нашей линии, то вставляет ее. Далее я иду по коммандам, для каждой команды вызываю функции `pickCache`, т.к. команды тоже лежат в памяти, вытаскиваю из них их аргументы и исполняю их в соотвествии с документацией. Если команда обращается в память, то я снова использую функцию `pickCache`.