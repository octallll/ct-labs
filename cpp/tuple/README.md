# Tuple

В данном задании вам нужно реализовать свою версию кортежа &mdash; [`std::tuple`](https://en.cppreference.com/w/cpp/utility/tuple).

Что нужно реализовать для `Tuple<Types...>`:

* Конструктор по умолчанию &mdash; производит value-инициализацию каждого элемента;
* Все специальные члены класса, которые посчитаете нужными;
* Конструктор от `UTypes&&...` &mdash; инициализирует элементы заданными значениями (достаточно поддерживать только случай, когда тип в паке `UTypes` &mdash; это соответствующий тип в паке `Types` по модулю ссылок и константности);
* Конструктор от `const Types&...` &mdash; помогает предыдущему с выводом типов;
* `make_tuple` &mdash; создаёт `tuple`, сам выводя типы. Обратите внимание, как он это делает в случае с ссылками (см. [cppref](https://en.cppreference.com/w/cpp/utility/tuple/make_tuple));
* Обращение к элементам:
    * `get<N>` &mdash; возвращает значение по заданному индексу;
    * `get<T>` &mdash; возвращает значение по заданному типу (если он встречается несколько раз, должна быть ошибка компиляции);
* Операторы сравнения (`==`, `<=>`) в лексикографическом порядке &mdash; определены только для кортежей одинакового размера;
* Вспомогательные трейты:
    * `tuple_size<T>` &mdash; количество элементов в кортеже `T`;
    * `tuple_element<N, T>` &mdash; тип `N`-го элемента в кортеже `T`;
* Функция `tuple_cat` для конкатенации произвольного числа кортежей (см. [cppref](https://en.cppreference.com/w/cpp/utility/tuple/tuple_cat)).

Пример:

```c++
Tuple<int, double, int> x {42, 3.14, 1337};
get<0>(x); // ok: 42
get<2>(x); // ok: 1337
get<double>(x); // ok: 3.14
get<3>(x); // compilation error
get<char>(x); // compilation error
get<int>(x); // compilation error
```

Некоторые конструкторы имеет смысл делать или не делать `explicit`, в зависимости от значений шаблонных параметров. Чтобы задавать такие условия, используется конструкция explicit(условие)
Поэтому подумайте, и где считаете нужными, расставьте explicit`, а также `noexcept`.
